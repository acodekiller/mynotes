# 一、MySQL体系结构和存储引擎

## 1、数据库和实例

数据库：物理操作系统文件或其他形式文件类型的集合。

实例：MySQL数据库由后台线程以及一个共享内存区组成。

> 在MySQL数据库中，实例与数据库的关通常系是一一对应的，即一个实例对应一个数据库，一个数据库对应一个实例。但是，在集群情况下可能存在一个数据库被多个数据实例使用的情况。

## 2、体系结构

![image-20220525231725967](imgs/image-20220525231725967.png)

- **连接池：**管理、缓冲用户的连接；
- **管理服务和工具组件：**系统管理和控制工具，如备份恢复、MySQL复制、集群等；
- **SQL接口组件：**接受用户的SQL命令，并且返回用户需要的查询结果；
- **查询分析器组件：**SQL命令传递到解析器时会被解析器验证和解析（权限、语法结构）；
- **优化器组件：**SQL语句在查询前会使用查询优化器进行优化；
- **缓冲组件：**如果查询缓存命中查询结果，查询语句可以从这里获得结果；
- **插件式存储引擎**
- **物理文件**

**存储引擎式基于表的，而不是数据库。**

## 3、存储引擎

### 1）InnoDB

InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用。其特点是行锁设计、支持外键，并支持类似于Oracle的非锁定读，即默认读取操作不会产生锁。

InnoDB通过使用多版本并发控制（MVCC）来获得高并发性，并且实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。

对于表中数据的存储，InnoDB存储引擎采用了聚集（clustered）的方式，因此每张表的存储都是按主键的顺序进行存放。

### 2）MyISAM

MyISAM存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些OLAP数据库应用。

MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。

### 3）Memory

将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据都将消失。它非常适合用于存储临时数据的临时表，以及数据仓库中的纬度表。Memory存储引擎默认使用哈希索引，而不是我们熟悉的B+树索引。

只支持表锁，并发性能较差，并且不支持TEXT和BLOB列类型。最重要的是，存储变长字段（varchar）时是按照定常字段（char）的方式进行的，因此会浪费内存。



---

# 二、InnoDB存储引擎

## 1、InnoDB 体系结构

![image-20220414180326882](imgs/image-20220414180326882.png)

### 1）后台线程

1. **Master Thread：**非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性。
2. **IO Thread：**主要负责IO请求的回调处理，包含write、read、insert buffer 和 log IO Thread。
3. **Purge Thread：**回收已经使用分配的undo页，如：事务提交后，其所使用的undolog可能不再需要了。
4. **Page Cleaner Thread：**处理脏页的刷新。

> 查看版本：`SHOW VARIABLES LIKE 'innodb_version'\G;`
>
> 查看状态：`SHOW INNODB STATUS\G;`

### 2）内存

![image-20220414180055038](imgs/image-20220414180055038.png)

1. **缓冲池：**缓冲池其实是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据性能的影响。

> **InnoDB存储引擎的内存管理**
>
> - LRU List：LRU列表用来管理已经读取的页。
> - Free List：LRU列表用来管理已经读取的页，但当数据库刚启动时，LRU列表是空的，即没有任何的页。这时页都存放在Free列表中。当需要从缓冲池中分页时，首先从Free列表中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入到LRU列表中。否则，根据LRU算法，淘汰LRU列表末尾的页，将该内存空间分配给新的页。
> - Flush List：在LRU列表中的页被修改后，称该页为脏页（dirty page），即缓冲池中的页和磁盘上的页的数据产生了不一致。Flush列表中的页即为脏页列表。需要注意的是，脏页既存在于LRU列表中，也存在于Flush列表中。LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘，二者互不影响。

2. **重做日志缓冲：**InnoDB存储引擎首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件。只需要保证每秒产生的事务量再这个缓冲大小之内即可。8MB的重做日志缓冲池足以满足绝大部分的应用。

> **以下三种情况会将重做日志缓冲中的内容刷新到外部磁盘的重做日志文件中：**
>
> 1. Master Thread 每一秒将重做日志缓冲刷新到重做日志文件；
> 2. 每个事务提交时会将重做日志缓冲刷新到重做日志文件；
> 3. 当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。

3. **额外的内存池：**在对一些数据结构本身的内存进行分配时，需要从而外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。

## 2、Checkpoint技术

### 1）目的

- **缩短数据库的恢复时间：**当数据库发生宕机时，数据库不需要重做所有的日志，因为Checkpoint之前的页都已经刷新回磁盘。故数据库只需对Checkpoint后的重做日志进行恢复。这样就大大缩短了恢复的时间；
- **缓冲池不够用时，将脏页刷新到磁盘：**当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷回磁盘；
- **重做日志不可用时，刷新脏页：**重做日志出现不可用的情况是因为当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大的，这从成本及管理上都是比较困难的。重做日志可以被重用的部分是指这些重做日志已经不再需要，即当数据库发生宕机时，数据库恢复操作不需要这部分的重做日志，因此这部分就可以被覆盖重用。若此时重做日志还需要使用，那么必须强制产生Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。

### 2）种类

1. **Sharp Checkpoint：**发生在数据库关闭时将所有的脏页都刷新到磁盘，这是默认的工作方式；
2. **Fuzzy Checkpoint：**只刷新一部分脏页。
   1. Master Thread Checkpoint：刷新一定比列的页回磁盘（异步过程，不会阻塞用户线程）；
   2. FLUSH_LRU_LIST Checkpoint：保证一定数量的空闲页可用，会阻塞用户的查询操作；
   3. Async/Sync Flush Checkpoint：保证重做日志的循环使用的可用性；
   4. Dirty Page too much Checkpoint：保证缓冲池有足够可用的页。

## 3、InnoDB关键特性

### 1）插入缓冲（Insert Buffer）

在InnoDB存储引擎中，主键是行唯一的标识符。通常应用程序中行记录的插入顺序是按照主键递增的顺序进行插入的。因此，插入聚集索引（Primary Key）一般是顺序的，不需要磁盘的随机读取。因此，对于这类情况下的插入操作，速度是非常快的。

对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中，好似欺骗。数据库这个非聚集的索引已经插到叶子节点，而实际并没有，只是存放在另一个位置。然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge（合并）操作，这时通常能将多个插入合并到一个操作中（因为在一个索引页中），这就大大提高了对于非聚集索引插入的性能。

> 使用条件：
>
> - 索引是辅助索引；
> - 索引不是唯一的。

### 2）两次写

**含义：**当使用重做日志进行数据恢复时发生写失效，即某个页本身已经发生了损坏，再对其进行重做是没有意义的。因此，在应用重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是doublewrite。

**过程：**

doublewrite由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是物理磁盘上共享表空间中连续的128个页，即2个区（extent），大小同样为2MB。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。在这个过程中，因为doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页的写入后，再将doublewrite buffer中的页写入各个表空间文件中，此时的写入则是离散的。

![image-20220526234033047](imgs/image-20220526234033047.png)

### 3）自适应哈希索引

InnoDB存储引擎会监控表上个索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引。

### 4）异步IO

为了提高磁盘操作性能，采用异步IO的方式来处理磁盘操作。

### 5）刷新临界表

当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，如果是脏页，那么一起进行刷新。

---

# 三、文件

## 1、参数文件

1.  **含义：**当MySQL实例启动时，数据库会先去读一个配置参数文件，用来寻找数据库的各种文件所在位置以及指定某些初始化参数。
2. **类型：**
   - 动态参数：可以在MySQL实例运行中进行修改；
   - 静态参数：在整个实例生命周期内都不能更改，就好像时只读的；
   - session：表明该参数的修改是基于当前会话的；
   - gloabal：表明该参数的修改是基于整个实例的生命周期；

## 2、日志文件

### 1）错误日志

在遇到问题时首先查看该文件以便定位问题，该文件不仅记录了所有的错误信息，也记录一些警告信息和正确的信息。

### 2）慢查询日志

慢查询日志可帮助DBA定位可能存在问题的SQL语句，从而进行SQL语句层面的优化。可以使用show variables like ‘slow_query_log’查看是否开启，如果状态值为OFF，可以使用 `set GLOBAL slow_query_log = on`来开启，它会在datadir下产生一个【主机名】-slow.log的文件。

- 查看阈值：`show VARIABLES like 'long_query_time'`
- 设置阈值：`set long_query_time=0.5`（大于0.5秒的SQL语句，正好等于long_query_time并不会被记录）

### 3）查询日志

记录了所有对MySQL数据库请求的信息。

### 4）二进制日志

1. 含义：二进制日志记录了对MySQL数据库执行更改的所有操作，即使这些操作并没有导致数据库发生变化。默认情况下是不开启的。
2. 作用：某些数据的恢复需要二进制日志；用作主从同步；判断是否有对数据库进行注入的攻击。
3. 记录格式：statement、row、mixed。

## 3、套接子文件

在UNIX系统下本地连接MySQL可以采用UNIX域套接字方式，这种方式需要一个套接字文件。

## 4、pid文件

当MySQL实例启动时，会将自己的进程ID写入到一个文件中——该文件即为pid文件。

## 5、表结构定义文件

MySQL数据的存储时根据表进行的，每个表都会有与之对应的文件，但不论表采用何种存储引擎，MySQL都有一个以frm为后缀的文件，这个文件记录了该表的表结构定义。

## 6、InnoDB存储引擎文件

### 1）表空间文件

InnoDB采用将存储的数据按表空间（tablespace）进行存放的设计，如果设置了`innodb_data_file_path`参数，所有基于InnoDB存储引擎的表的数据都会记录到该共享表空间中。若设置了`innodb_file_per_table`，则用户可以将每个基于InnoDB存储引擎的表产生一个独立表空间。独立表空间的命名规则为：`表名.ibd`。通过这样的方式，用户不用将所有数据都存放于默认的表空间中。

### 2）重做日志文件

当实例或介质失败时，重做日志文件就能派上用场。

重做日志文件的大小设置对于InnoDB存储引擎的性能有着非常大的影响。一方面重做日志文件不能设置得太大，如果设置得很大，在恢复时可能需要很长的时间；另外一方面又不能设置得太小了，否则可能导致一个事务得日志需要多次切换重做日志文件。此外，重做日志文件太小会导致频繁地发生async checkpoint，导致性能地抖动。



---

# 四、表

## 1、索引组织表

在InnoDB存储引擎中，表都是根据主键顺序组织存放的，这种存储结构的表称为索引组织表。

> 在InnoDB存储引擎表中，每张表都有个主键（Primary Key），如果在创建表时没有显式地定义主键，则InnoDB存储引擎会按如下方式选择或创建主键： 
>
> ❑首先判断表中是否有非空的唯一索引（Unique NOT NULL），如果有，则该列即为主键。 
>
> ❑如果不符合上述条件，InnoDB存储引擎自动创建一个6字节大小的指针。
>
> 当表中有多个非空唯一索引时，InnoDB存储引擎将选择建表时第一个定义的非空唯一索引为主键。这里需要非常注意的是，主键的选择根据的是定义索引的顺序，而不是建表时列的顺序。

## 2、InnoDB逻辑存储结构

从InnoDB存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间（tablespace）。表空间又由段（segment）、区（extent）、页（page）组成。页在一些文档中有时也称为块（block）。

![image-20220602200923135](imgs/image-20220602200923135.png)

1. 表空间：表空间可以看做是存储引擎逻辑结构的最高层，所有的数据（数据、索引和插入缓冲Bitmap页，及其他类的数据，如回滚（undo）信息，插入缓冲索引页、系统事务信息，二次写缓冲（Double write buffer）等）都存放在表空间中。
2. 段：常见的段有数据段（索引）、索引段（非索引节点）、回滚段等。
3. 区：由连续页组成的空间，在任何情况下每个区的大小都为1MB。
4. 页：页是InnoDB磁盘管理的最小单位。
5. 行：InnoDB存储引擎是面向列的，也就说数据是按行进行存放的。

## 3、InnoDB行记录格式

1. Compact：在MySQL5.0中引入的，其设计目标是高效地存储数据；
2. Redundant：为了兼容之前版本地也格式；
3. Compressed：新的文件格式，常常在其中地行数据会以zlib的算法进行压缩；
4. Dynamic。

> 查看当前表使用的行格式：`SHOW TABLE STATUS LIKE 'mytest%'\G`

## 4、InnoDB数据页结构

![image-20220604164226074](imgs/image-20220604164226074.png)

## 5、约束

### 1）数据完整性

一般来说，数据完整性有以下三种形式：

1. 实体完整性：保证表重要有一个主键；
2. 域完整性：保证数据每列的值满足特定的条件；
3. 参照完整性：保证两张表之间的关系。

> 对于InnoDB存储引擎本身而言，提供了以下几种约束：
>
> - Primary Key 
> - Unique Key 
> - Foreign Key 
> - Default 
> - NOT NULL

### 2）约束和索引的区别

当用户创建了一个唯一索引就创建了一个唯一的约束。但是约束和索引的概念还是有所不同的，约束更是一个逻辑的概念，用来保证数据的完整性，而索引是一个数据结构，既有逻辑上的概念，在数据库中还代表着物理存储的方式。

### 3）ENUM和SET约束

MySQL数据库不支持传统的CHECK约束，但是通过ENUM和SET类型可以解决部分这样的约束需求。

例如表上有一个性别类型，规定域的范围只能是male或female，在这种情况下用户可以通过ENUM类型来进行约束。

![image-20220604172808781](imgs/image-20220604172808781.png)

### 4）触发器与约束

触发器的作用是在执行INSERT、DELETE和UPDATE命令之前或之后自动调用SQL命令或存储过程。

通过触发器，用户可以实现MySQL数据库本身并不支持的一些特性，如对于传统CHECK约束的支持，物化视图、高级复制、审计等特性。

### 5）外键约束

> 外键用来保证参照完整性，MySQL数据库的MyISAM存储引擎本身并不支持外键，对于外键的定义只是起到一个注释的作用。

外键的定义如下：

![image-20220604173527421](imgs/image-20220604173527421.png)

（外键定义时的ON DELETE和ON UPDATE表示在对父表进行DELETE和UPDATE操作时，对子表所做的操作）

1. **CASCADE** ：表示当父表发生DELETE或UPDATE操作时，对相应的子表中的数据也进行DELETE或UPDATE操作；
2. **SET NULL** ：当父表发生DELETE或UPDATE操作时，相应的子表中的数据被更新为NULL值，但是子表中相对应的列必须允许为NULL值；
3. **NO ACTION**： 当父表发生DELETE或UPDATE操作时，抛出错误，不允许这类操作发生；
4. **RESTRICT**：当父表发生DELETE或UPDATE操作时，抛出错误，不允许这类操作发生。

如果定义外键时没有指定ON DELETE或ON UPDATE，RESTRICT就是默认的外键设置。由于MySQL数据库的外键约束都是即时检查（immediate check），因此在MySQL数据库中NO ACTION和RESTRICT的功能是相同的。

## 6、视图

视图（View）是一个命名的虚表，它由一个SQL查询来定义，可以当做表使用。与持久表（permanent table）不同的是，视图中的数据没有实际的物理存储。

视图的主要用途之一是被用做一个抽象装置，特别是对于一些应用程序，程序本身不需要关心基表（base table）的结构，只需要按照视图定义来取数据或更新数据，因此，视图同时在一定程度上起到一个安全层的作用。

## 7、分区表

### 1）概述

分区功能并不是在存储引擎层完成的，因此不是只有InnoDB存储引擎支持分区，常见的存储引擎MyISAM、NDB等都支持。但也并不是所有的存储引擎都支持。

分区的过程是将一个表或索引分解为多个更小、更可管理的部分。就访问数据库的应用而言，从逻辑上讲，只有一个表或一个索引，但是在物理上这个表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。

> **子分区**
>
> 子分区是在分区的基础上再进行分区，有时也称这种分区为复合分区。MySQL数据库允许在RANGE和LIST的分区上再进行HASH或KEY的子分区，

### 2）类型

1. RANGE分区：行数据基于属于一个给定连续区间的列值被放入分区；
2. LIST分区：和RANGE分区类型，只是LIST分区面向的是离散的值；
3. HASH分区：根据用户自定义的表达式的返回值来进行分区，返回值不能为负数；
4. KEY分区：根据MySQL数据库提供的哈希函数来进行分区；
5. COLUMNS分区：可视为RANGE分区和LIST分区的一种进化。COLUMNS分区可以直接使用非整型的数据进行分区，分区根据类型直接比较而得，不需要转化为整型。此外，RANGECOLUMNS分区可以对多个列的值进行分区。

### 3）分区和性能

对于OLAP的应用，分区的确是可以很好地提高查询的性能，因为OLAP应用大多数查询需要频繁地扫描一张很大的表。假设有一张1亿行的表，其中有一个时间戳属性列。用户的查询需要从这张表中获取一年的数据。如果按时间戳进行分区，则只需要扫描相应的分区即可。这就是前面介绍的Partition Pruning技术。

然而对于OLTP的应用，分区应该非常小心。在这种应用下，通常不可能会获取一张大表中10%的数据，大部分都是通过索引返回几条记录即可。而根据B+树索引的原理可知，对于一张大表，一般的B+树需要2～3次的磁盘IO。因此B+树可以很好地完成操作，不需要分区的帮助，并且设计不好的分区会带来严重的性能问题。



---

# 五、索引与算法

、